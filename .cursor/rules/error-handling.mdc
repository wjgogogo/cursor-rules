---
description: 
globs: 
alwaysApply: true
---
# 错误处理规范

## 核心原则 [P0]

【必须】建立统一的错误处理策略：
- 分层错误处理：组件级 → 页面级 → 应用级
- 用户友好的错误提示
- 完整的错误日志记录
- 优雅的错误恢复机制

## 错误类型定义 [P0]

【必须】使用统一的错误类型：

```tsx
interface AppError {
  type: 'validation' | 'network' | 'business' | 'system';
  code: string;
  message: string;
  timestamp: string;
}

// 快速创建错误
const createError = (type: AppError['type'], code: string, message: string): AppError => ({
  type,
  code,
  message,
  timestamp: new Date().toISOString(),
});
```

## API 错误处理 [P0]

【必须】统一处理 API 错误：

```tsx
async function apiRequest<T>(url: string, options?: RequestInit): Promise<T> {
  try {
    const response = await fetch(url, options);
    
    if (!response.ok) {
      throw createError('network', `HTTP_${response.status}`, `请求失败: ${response.statusText}`);
    }
    
    return response.json();
  } catch (error) {
    if (error instanceof TypeError) {
      throw createError('network', 'NETWORK_ERROR', '网络连接失败');
    }
    throw error;
  }
}
```

## 全局错误处理 [P1]

【必须】设置全局错误处理器：

```tsx
// 在应用根组件中设置
function setupGlobalErrorHandlers() {
  // 未捕获的 Promise 错误
  window.addEventListener('unhandledrejection', (event) => {
    console.error('未处理的 Promise 错误:', event.reason);
    // 上报错误到监控系统
  });

  // 未捕获的 JavaScript 错误
  window.addEventListener('error', (event) => {
    console.error('JavaScript 错误:', event.error);
    // 上报错误到监控系统
  });
}
```

## 错误日志记录 [P1]

【必须】记录错误详情：

```tsx
function logError(error: AppError, context?: Record<string, any>) {
  const logData = {
    ...error,
    context,
    url: window.location.href,
    userAgent: navigator.userAgent,
  };

  // 开发环境：控制台输出
  if (process.env.NODE_ENV === 'development') {
    console.error('Error:', logData);
  }

  // 生产环境：发送到监控服务
  if (process.env.NODE_ENV === 'production') {
    // 发送到 Sentry、LogRocket 等服务
  }
}
```

## 重试机制 [P2]

【推荐】为网络请求添加重试：

```tsx
async function withRetry<T>(
  operation: () => Promise<T>,
  maxRetries: number = 3
): Promise<T> {
  for (let i = 0; i <= maxRetries; i++) {
    try {
      return await operation();
    } catch (error) {
      if (i === maxRetries) throw error;
      await new Promise(resolve => setTimeout(resolve, 1000 * i));
    }
  }
  throw new Error('重试次数已用完');
}
```

## 🔍 检查清单

### 核心要求 [P0]
- [ ] **错误捕获**：关键功能都有错误处理
- [ ] **用户提示**：错误信息对用户友好
- [ ] **错误边界**：组件错误不会崩溃整个应用

### 质量提升 [P1]
- [ ] **日志记录**：错误信息完整记录
- [ ] **全局处理**：设置全局错误处理器

### 可选优化 [P2]
- [ ] **重试机制**：网络错误提供重试选项
- [ ] **优雅降级**：错误时应用仍可基本使用 
