---
description: 
globs: *.js,*.jsx,*.ts,*.tsx
alwaysApply: false
---
# 性能优化规范

本规范定义了 React 应用的性能优化最佳实践。

## Suspense 和错误边界

- 将客户端组件用 Suspense 包装并提供 fallback
- 为异步组件提供加载状态

```tsx
// ✅ 正确示例
function App() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <UserDashboard />
    </Suspense>
  );
}

function LoadingSpinner() {
  return (
    <div className="flex items-center justify-center p-4">
      <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900"></div>
    </div>
  );
}
```

## 动态加载

- 对非关键组件使用动态加载
- 延迟加载重型组件

```tsx
// ✅ 正确示例 - 动态加载
import { lazy, Suspense } from 'react';

const HeavyChart = lazy(() => import('./HeavyChart'));

function Dashboard() {
  return (
    <div>
      <h1>仪表板</h1>
      <Suspense fallback={<div>加载图表中...</div>}>
        <HeavyChart />
      </Suspense>
    </div>
  );
}
```

## 内存优化

- 正确清理 useEffect 中的副作用
- 移除事件监听器和定时器
- 避免内存泄漏

```tsx
// ✅ 正确示例 - 内存清理
function WindowSizeTracker() {
  const [windowSize, setWindowSize] = useState({ width: 0, height: 0 });

  useEffect(() => {
    function handleResize() {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    }

    window.addEventListener('resize', handleResize);
    
    // 清理函数防止内存泄漏
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  return <div>{windowSize.width} x {windowSize.height}</div>;
}

// ❌ 错误示例 - 未清理副作用
function BadTimer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    setInterval(() => { // 内存泄漏：未清理定时器
      setCount(prev => prev + 1);
    }, 1000);
  }, []);

  return <div>计数: {count}</div>;
}
```

## 渲染优化

- 最小化 `useEffect` 和 `useState` 的使用
- 使用 React.memo 防止不必要的重新渲染
- 合理使用 useMemo 和 useCallback
- 实现虚拟化长列表

```tsx
// ✅ 正确示例 - React.memo 优化
interface UserCardProps {
  user: User;
  onEdit: (user: User) => void;
}

const UserCard = React.memo(function UserCard({ user, onEdit }: UserCardProps) {
  return (
    <div className="card">
      <h3>{user.name}</h3>
      <button onClick={() => onEdit(user)}>编辑</button>
    </div>
  );
});

// ✅ 正确示例 - useMemo 和 useCallback 优化
function UserList({ users, onUserEdit }: { users: User[]; onUserEdit: (user: User) => void }) {
  // 缓存计算结果
  const sortedUsers = useMemo(() => {
    return users.sort((a, b) => a.name.localeCompare(b.name));
  }, [users]);

  // 缓存回调函数
  const handleUserEdit = useCallback((user: User) => {
    onUserEdit(user);
  }, [onUserEdit]);

  return (
    <div>
      {sortedUsers.map(user => (
        <UserCard 
          key={user.id} 
          user={user} 
          onEdit={handleUserEdit}
        />
      ))}
    </div>
  );
}
```

## 网络性能优化

- 实现请求去重和缓存
- 控制并发请求数量
- 使用合理的重试机制

```tsx
// ✅ 正确示例 - 请求去重
const requestCache = new Map<string, Promise<any>>();

function fetchWithDeduplication<T>(url: string): Promise<T> {
  if (requestCache.has(url)) {
    return requestCache.get(url)!;
  }

  const promise = fetch(url)
    .then(response => response.json())
    .finally(() => {
      // 请求完成后清除缓存
      requestCache.delete(url);
    });

  requestCache.set(url, promise);
  return promise;
}
```

## 用户交互优化

- 实现防抖和节流
- 优化表单性能
- 减少布局抖动

```tsx
// ✅ 正确示例 - 防抖 Hook
function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

// ✅ 正确示例 - 搜索组件使用防抖
function SearchInput({ onSearch }: { onSearch: (query: string) => void }) {
  const [query, setQuery] = useState('');
  const debouncedQuery = useDebounce(query, 300);

  useEffect(() => {
    if (debouncedQuery) {
      onSearch(debouncedQuery);
    }
  }, [debouncedQuery, onSearch]);

  return (
    <input
      type="text"
      value={query}
      onChange={(e) => setQuery(e.target.value)}
      placeholder="搜索..."
      className="w-full p-2 border rounded"
    />
  );
}
```

## Bundle 和构建优化

- 实现有效的代码分割
- 优化依赖和 Tree-shaking
- 分析和优化包体积

```tsx
// ✅ 正确示例 - 路由级代码分割
import { lazy } from 'react';
import { Routes, Route } from 'react-router-dom';

// 按路由分割代码
const Home = lazy(() => import('./pages/Home'));
const Profile = lazy(() => import('./pages/Profile'));
const Settings = lazy(() => import('./pages/Settings'));

function App() {
  return (
    <Suspense fallback={<div>加载中...</div>}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/profile" element={<Profile />} />
        <Route path="/settings" element={<Settings />} />
      </Routes>
    </Suspense>
  );
}

// ✅ 正确示例 - 按需导入工具库
// 好的做法：只导入需要的函数
import { debounce, throttle } from 'lodash-es';

// ❌ 错误示例：导入整个库
import _ from 'lodash'; // 这会导入整个 lodash 库
```
